# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controller: [lookup:[int256]:int256, assertIsWhitelisted:[int256]:int256]

REGISTRATION_TOKEN = self.controller.lookup('registrationToken')
extern registrationToken: [a:[]_]

REPUTATION_TOKEN = self.controller.lookup('reputationToken')
extern reputationToken: [b:[]_]

BRANCH_ACTIONS = self.controller.lookup('branchActions')
extern branches: [c:[]_]

REPORTING = self.controller.lookup('reporting')
extern reporting: [d:[]_]

inset('../macros/refund.sem')
inset('../macros/safeMath.sem')
inset('../macros/assertPrivateCall.sem')
inset('../macros/unitConversions.sem')

data controller

data nextMarketId
data markets[2**64]
# takes branch, reportingWindow, phase as keys; value: 0 - finalized, 1 - automated reporting, 2 - limited reporting, 3 - all reporting, 4 - forking
data marketCounts[][][]

def init():
    self.controller = 0x0
    self.nextMarketId = 1

def any():
    refund()

def createMarket(branchId, endTime, description, automatedReporterAddress):
    # TODO: assert the user sent enough fees and validity bond
    # TODO: assert not a duplicate event. CONSIDER: is this actually necessary?
    marketId = self.nextMarketId
    self.nextMarketId += 1
    newMarket = create('market')
    newMarket.initialize(marketId, branchId, endTime, description, automatedReporterAddress)
    self.markets[marketId] = newMarket
    marketCounts[newMarket.getBranchId()][newMarket.getReportingWindow()][2] += 1
    return(newMarket)

# FIXME: figure out a better way to deal with limited/all reporters market counts. what we want to do is:
#   FIXME: markets
#   FIXME:     filter(market => market.branchId == branch)
#   FIXME:     filter(market => market.reportingWindow == reportingWindow)
#   FIXME:     filter(market => market.getReportingPhase() == <limited/all>)
#   FIXME:     count()
#   FIXME: but we can't do unbounded operations like that in the EVM, so we need a solution that involves keeping a running count as markets move between branches/reporting windows/phases. if a better solution isn't found then this code will need some extensive auditing to ensure we don't miss any movements
def notifyMarketMovement(market, oldBranchId, newBranchId, oldReportingWindow, newReportingWindow, oldPhase, newPhase):
    self.assertCallerIsMarket(msg.sender)
    self.marketCounts[oldBranchId][oldReportingWindow][oldPhase] -= 1
    self.marketCounts[newBranchId][newReportingWindow][newPhase] += 1

####
#### Getters
####

def getMarket(marketId):
    market = self.markets[marketId]
    if (not market):
        ~invalid()
    return(market)

def getNumberOfLimitedReporterEvents(branchId, reportingWindow):
    return(self.marketCounts[branchId][reportingWindow][2])

def getNumberOfAllReporterEvents(branchId, reportingWindow):
    return(self.marketCounts[branchId][reportingWindow][3])

####
#### Asserts
####

def assertCallerIsMarket(callerAddress):
    if (self.markets[callerAddress.getMarketId()] != callerAddress):
        ~invalid()

####
#### Private
####
