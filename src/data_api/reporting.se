# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controller: [lookup:[int256]:int256, assertIsWhitelisted:[int256]:int256]

EVENTS = self.controller.lookup('events')
extern events: [a:[]:_]

REGISTRATION_TOKEN = self.controller.lookup('registrationToken')
extern registrationToken: [b:[]:_]

inset('../macros/refund.sem')
inset('../macros/safeMath.sem')
inset('../macros/unitConversions.sem')

data controller
data reportingPeriodSeconds
data reportingDisputePeriodSeconds
data reportsPerEvent
# userReports[branch][reportingWindow][reporterAddress]
data userReports[][][](markets[], count)
# marketReporterCount[branch][reportingWindow][market] => count
data marketReporterCount[][][]

def init():
    self.controller = 0x0
    self.reportingPeriodSeconds = 21 * SECONDS_PER_DAY
    self.reportingDisputePeriodSeconds = 3 * SECONDS_PER_DAY
    self.reportsPerEvent = 7

def any():
    refund()

# FIXME: gas issue, may cost a lot to run but should come with a hefty gas refund
# CONSIDER: if we dis-allow multiple registration token redemptions then we can just set the `.count` to 0
def clearUserReports(branch, reportingWindow, reporterAddress):
    self.controller.assertIsWhitelisted(msg.sender)
    i = 0
    while(i < self.userReports[branch][reportingWindow][reporterAddress].count):
        market = self.userReports[branch][reportingWindow][reporterAddress].markets[i]
        self.userReports[branch][reportingWindow][reporterAddress].markets[i] = 0
        self.marketReporterCount[branch][reportingWindow][market] -= 1
        i += 1
    self.userReports[branch][reportingWindow][reporterAddress].count = 0
    return(1)

def noteUserReport(marketId, outcome, reporter):
    # trustlessly verify that the user has in fact reported on the given market, this way we don't have to whitelist all markets/reporting tokens
    market = EVENTS.getMarket(marketId)
    market.assertCanBeReportedOn()
    reportingToken = market.getReportingToken()
    reportingToken.assertReporterHasReported(outcome, reporter)
    branchId = market.getBranchId()
    window = self.getCurrentReportingWindow()
    # always give credit for events in all-reporters phase
    if (market.getReportingPhase() == 3):
        self.privateNoteUserReport(market, reporter)
    # only events in limited/all reporting phase are valid to report on
    else if (market.getReportingPhase() != 2):
        ~invalid()
    # only give credit for limited reporter markets up to the max reporters for that market
    marketReporterCount = self.marketReporterCount[branchId][window][reporter]
    maxReportsPerLimitedReporterMarket = self.getMaxReportsPerLimitedReporterMarket(branchId, window)
    if (marketReporterCount < maxReportsPerLimitedReporterMarket):
        self.privateNoteUserReport(market, reporter)

####
#### Helpers
####

####
#### Getters
####

def isInReportingPhase():
    startTime = self.getCurrentReportingWindowStartTimestamp()
    endTime = startTime + self.reportingPeriodSeconds
    nowIsAfterStartTime = block.timestamp > startTime
    nowIsBeforeEndTime = block.timestamp < endTime
    return(nowIsAfterStartTime && nowIsBeforeEndTime)

def isInReportingDisputePhase():
    startTime = self.getCurrentReportingWindowStartTimestamp() + self.reportingPeriodSeconds
    endTime = startTime + self.reportingDisputePeriodSeconds
    nowIsAfterStartTime = block.timestamp > startTime
    nowIsBeforeEndTime = block.timestamp < endTime
    return(nowIsAfterStartTime && nowIsBeforeEndTime)

def getReportingPeriodDurationInSeconds():
    return(self.reportingPeriodSeconds + self.reportingDisputePeriodSeconds)

def getCurrentReportingWindow():
    return(self.getReportingWindowForTimestamp(block.timestamp))

def getReportingWindowForTimestamp(timestamp):
    return(timestamp / self.getReportingPeriodDurationInSeconds())

def getCurrentReportingWindowStartTimestamp():
    return(self.getCurrentReportingWindow() * self.getReportingPeriodDurationInSeconds())

def getCurrentReportingWindowEndTimestamp():
    return(self.getCurrentReportingWindowStartTimestamp() + self.getReportingPeriodDurationInSeconds())

def getTargetReportsPerLimitedReporterMarket(branchId, reportingWindow):
    limitedReporterMarketCount = EVENTS.getNumberOfLimitedReporterEvents(branchId, reportingWindow)
    reportersThisSession = REGISTRATION_TOKEN.totalSupply(branchId, reportingWindow)
    minimumReportsPerMarket = 7

    if (reportersThisSession > (minimumReportsPerMarket * limitedReporterMarketCount)):
        factor = reportersThisSession / (minimumReportsPerMarket * limitedReporterMarketCount)
        minimumReportsPerMarket = minimumReportsPerMarket * factor

def getMaxReportsPerLimitedReporterMarket(branchId, reportingWindow):
    return(self.getTargetReportsPerLimitedReporterMarket(branchId, reportingWindow) + 2)

def getRequiredReportsPerReporterForLimitedReportingMarkets(branchId, reportingWindow):
    targetReportsPerMarket = self.getTargetReportsPerLimitedReporterMarket(branchId, reportingWindow)
    limitedReporterMarketCount = EVENTS.getNumberOfLimitedReporterEvents(branchId, reportingWindow)
    reportersThisSession = REGISTRATION_TOKEN.totalSupply(branchId, reportingWindow)
    reportsPerReporter = targetReportsPerMarket * limitedReporterMarketCount / reportersThisSession
    return(reportsPerReporter)

def getRequiredReportsPerReporter(branchId, reportingWindow):
    limitedMarketReportsPerReporter = getRequiredReportsPerReporterForLimitedReportingMarkets(branchId, reportingWindow)
    allReporterMarketsCount = EVENTS.getNumberOfAllReporterEvents(branchId, reportingWindow)
    return(allReporterMarketsCount + limitedMarketReportsPerReporter)

####
#### Asserts
####

# CONSIDER: if an event moves out of a reporting period (e.g., due to a fork) this may start to return an incorrect result; can events move out of a reporting window _during_ a reporting window?
def assertDoneReporting(branch, reportingWindow, reporterAddress):
    totalAllReporterEvents = EVENTS.getNumberOfAllReporterEvents(branch, reportingWindow)
    totalLimitedReporterEvents = EVENTS.getNumberOfLimitedReporterEvents(branch, reportingWindow)
    targetReports = self.getTargetReportsPerReporter(branch, reportingWindow)
    # TODO: test this to make sure that a user can't run out of events without reaching target
    if (self.userReports[branch][reportingWindow][reporterAddress].reportedEventsCount < targetReports):
        ~invalid()

####
#### Private
####

def privateNoteUserReport(market, reporter):
    assertPrivateCall()
    branchId = market.getBranchId()
    window = self.getCurrentReportingWindow()
    if (self.userReports[branchId][window][reporter].markets[market]):
        return
    oldCount = self.userReports[branchId][window][reporter].count
    self.userReports[branchId][window][reporter].count = safeAdd(oldCount, 1)
    self.userReports[branchId][window][reporter].markets[market] = 1
    self.marketReporterCount[branchId][window][market] += 1
