# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controller: [lookup:[int256]:int256, checkWhitelist:[int256]:int256]
extern events: [allowance:[int256,int256]:uint256, approve:[int256,int256]:int256, assertEventIsInAutomatedReportDisputePhase:[int256]:int256, assertEventIsInAutomatedReportPhase:[int256]:int256, assertEventIsInCurrentReportingWindow:[int256]:int256, assertEventIsInDisputePhase:[int256]:int256, assertEventIsInReportingPhase:[int256]:int256, assertEventIsNotDoneWithReporters:[int256]:int256, assertEventIsNotFinalized:[int256]:int256, assertReporterHasRegistrationToken:[int256]:int256, automatedReport:[int256,int256]:_, balanceOf:[int256,int256,int256,int256]:uint256, createEvent:[int256,int256,int256,int256]:int256, disputeAllReporters:[int256]:_, disputeAutomatedReport:[int256]:_, disputeLimitedReporters:[int256]:_, finalizeEvent:[int256]:_, getAutomatedReportDisputeDueTimestamp:[int256]:int256, getAutomatedReportDueTimestamp:[int256]:int256, getEventBranch:[int256]:int256, getNumberOfAllReporterEvents:[int256,int256]:int256, getNumberOfLimitedReporterEvents:[int256,int256]:int256, isEventFinalized:[int256]:int256, migrateEventThroughAllForks:[int256]:int256, migrateEventThroughOneFork:[int256]:int256, privateAdjustTentativeOutcome:[int256,int256]:_, privateBuyToken:[int256,int256,int256,int256]:_, privateRedeemCorrectOutcomeTokens:[int256,int256,int256,int256]:int256, privateTransfer:[int256,int256,int256,int256,int256,int256]:int256, privateTryRedeemTokensForNonForkingEventOnForkedBranch:[int256,int256,int256,int256]:int256, privateTryRedeemTokensOnForkingEvent:[int256,int256,int256,int256]:int256, redeemTokens:[int256,int256,int256]:int256, report:[int256,int256,int256]:int256, totalSupply:[int256,int256,int256]:uint256, transfer:[int256,int256,int256,int256,int256]:int256, transferFrom:[int256,int256,int256,int256,int256,int256]:int256, tryFinalizeEvent:[int256]:int256]

inset('../macros/refund.sem')
inset('../macros/safeMath.sem')
inset('../macros/unitConversions.sem')

data controller
data reportingPeriodSeconds
data reportingDisputePeriodSeconds
data reportsPerEvent
# userReports[branch][reportingWindow][reporterAddress]
data userReports[][][](reportedEvents[], reportedEventsCount, seed)

def init():
    self.controller = 0x0
    self.reportingPeriodSeconds = 21 * SECONDS_PER_DAY
    self.reportingDisputePeriodSeconds = 3 * SECONDS_PER_DAY
    self.reportsPerEvent = 7

def any():
    refund()

# TODO: simplify this to allow people to report on any event, as long as it doesn't already have too many reporters
# only to be called for events being reported on by a subset of reporters, up to caller to make sure the event is generally elligible for reporting right now
def assertCanReportOnEvent(eventId, reporterAddress):
    # CONSIDER: change this scheme to just disallowing more than `n` reports per event, but allow anyone to report on anything
    branch = self.controller.lookup('events').getEventBranch(eventId)
    currentReportingWindow = self.getCurrentReportingWindow()
    seed = self.getUserSeed(branch, currentReportingWindow, reporterAddress)
    reportsPerReporter = self.getTargetReportsPerReporter(branch, reportingWindow)
    # TODO: run a monte carlo simulation to verify this algorithm is reasonable
    # TODO: figure out a variable name for this that makes sense to readers at a glance
    # TODO: ensure this is tested for pathological cases like prime # of markets & prime # of reporters and 0 events and 1 event
    personallyIndexedEvent = sha3([eventId, seed], items = 2) % totalReporters
    if (personallyIndexedEvent >= reportsPerReporter):
        ~invalid()
    return(1)

# FIXME: if an event moves out of a reporting period (e.g., due to a fork) this may start to return an incorrect result
def assertDoneReporting(branch, reportingWindow, reporterAddress):
    eventsContract = self.controller.lookup('events')
    totalAllReporterEvents = eventsContract.getNumberOfAllReporterEvents(branch, reportingWindow)
    totalLimitedReporterEvents = eventsContract.getNumberOfLimitedReporterEvents(branch, reportingWindow)
    targetReports = self.getTargetReportsPerReporter(branch, reportingWindow)
    # TODO: test this to make sure that a user can't run out of events without reaching target
    if (self.userReports[branch][reportingWindow][reporterAddress].reportedEventsCount < targetReports):
        ~invalid()
    return(1)

# FIXME: gas issue
def clearUserReports(branch, reportingWindow, reporterAddress):
    self.controller.checkWhitelist(msg.sender)
    i = 0
    while(i < self.userReports[branch][reportingWindow][reporterAddress].reportedEventsCount):
        self.userReports[branch][reportingWindow][reporterAddress].reportedEvents[i] = 0
        i += 1
    self.userReports[branch][reportingWindow][reporterAddress].reportedEventsCount = 0
    self.userReports[branch][reportingWindow][reporterAddress].seed = 0
    return(1)

def noteUserReport(branch, eventId):
    self.controller.checkWhitelist(msg.sender)
    currentReportingWindow = self.getCurrentReportingWindow()
    startingEventCount = self.userReports[branch][currentReportingWindow][reporterAddress].reportedEventsCount
    self.userReports[branch][currentReportingWindow][reporterAddress].reportedEvents[startingEventCount] = eventId
    self.userReports[branch][currentReportingWindow][reporterAddress].reportedEventsCount = safeAdd(startingEventCount, 1)
    return(1)

def isInReportingPhase():
    startTime = self.getCurrentReportingWindowStartTimestamp()
    endTime = startTime + self.reportingPeriodSeconds
    nowIsAfterStartTime = block.timestamp > startTime
    nowIsBeforeEndTime = block.timestamp < endTime
    return(nowIsAfterStartTime && nowIsBeforeEndTime)

def isInReportingDisputePhase():
    startTime = self.getCurrentReportingWindowStartTimestamp() + self.reportingPeriodSeconds
    endTime = startTime + self.reportingDisputePeriodSeconds
    nowIsAfterStartTime = block.timestamp > startTime
    nowIsBeforeEndTime = block.timestamp < endTime
    return(nowIsAfterStartTime && nowIsBeforeEndTime)

def getReportingPeriodDurationInSeconds():
    return(self.reportingPeriodSeconds + self.reportingDisputePeriodSeconds)

def getCurrentReportingWindow():
    return(self.getReportingWindowForTimestamp(block.timestamp))

def getReportingWindowForTimestamp(timestamp):
    return(timestamp / self.getReportingPeriodDurationInSeconds())

def getCurrentReportingWindowStartTimestamp():
    return(self.getCurrentReportingWindow() * self.getReportingPeriodDurationInSeconds())

def getCurrentReportingWindowEndTimestamp():
    return(self.getCurrentReportingWindowStartTimestamp() + self.getReportingPeriodDurationInSeconds())

def getTargetReportsPerReporter(branch, reportingWindow):
    numberOfLimitedReporterEvents = self.controller.lookup('events').getNumberOfLimitedReporterEvents(branch, reportingWindow)
    numberOfAllReporterEvents = self.controller.lookup('events').getNumberOfAllReporterEvents(branch, reportingWindow)
    totalReporters = self.controller.lookup('registrationToken').totalSupply(branch, reportingWindow)
    totalLimitedReporterReports = safeMul(numberOfLimitedReporterEvents, self.reportsPerEvent)
    reportsPerReporter = safeAdd(safeDiv(totalLimitedReporterReports, totalReporters), numberOfAllReporterEvents)
    return(reportsPerReporter)

def getUserSeed(branch, reportingWindow, reporterAddress):
    seed = self.userReports[branch][reportingWindow][reporterAddress].seed
    if (seed == 0):
        seed = sha3([reporterAddress, block.prevhash], items = 2)
        self.userReports[branch][reportingWindow][reporterAddress].seed = seed
    return(seed)
