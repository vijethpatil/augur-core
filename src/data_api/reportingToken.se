# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controller: [lookup:[int256]:int256, assertIsWhitelisted:[int256]:int256]

REPUTATION_TOKEN = self.controller.lookup('reputationToken')
extern reputationToken: [transfer:[uint256, address, uint256]:_, transferFrom:[uint256,address,address,uint256]:_, balanceOf:[uint256,address]:uint256]

REPORTING = self.controller.lookup('reporting')
extern reporting: [noteUserReport:[uint256, uint256]:_]

REGISTRATION_TOKEN = self.controller.lookup('registrationToken')
extern registrationToken: [balanceOf:[uint256,uint256,uint256]:uint256]

inset('../macros/refund.sem')
inset('../macros/assertPrivateCall.sem')
inset('../macros/safeMath.sem')

# 2** 128 = outcome; 2**160 = reporter
data controller
data market
data branchId
data tokens[2**128][2**160]
data tokenSupply[2**128]
data allOutcomeTokenSupply
data winningOutcome

def init():
    self.controller = 0x0

def any():
    refund()

def initialize(market, branchId):
    self.market = market
    self.branchId = branchId

def buy(outcome, attorep):
    market = self.market
    branchId = self.branchId
    reporter = msg.sender
    market.assertCanBeReportedOn()
    self.assertMarketIsNotDoneWithReporters()
    self.assertReporterHasRegistrationToken(reporter)
    self.assertBranchMatchesMarketBranch()
    REPUTATION_TOKEN.transferFrom(branchId, reporter, self, attorep)
    self.privateCreateAndAssignTokens(outcome, reporter, attorep)
    self.privateAdjustWinningOutcome(outcome)
    REPORTING.noteUserReport(marketId, outcome, reporter)

def transfer(outcome, destination, attotokens):
    source = msg.sender
    startingSourceTokens = tokens[outcome][source]
    startingDestinationTokens = tokens[outcome][destination]
    tokens[outcome][source] = safeSub(startingSourceTokens, attotokens)
    tokens[outcome][destination] = safeAdd(startingDestinationTokens, attotokens)

def redeem(outcome, reporter):
    isForkingMarket = # TODO: figure out how to identify whether an market was a forking market or not, and what its pre-fork branch was

    # if this contract is for tokens purchased prior to a fork migration, redeem all outcomes at face value
    if (self.market.getBranch() != self.branch and not isForkingMarket):
        self.privateRedeemTokensAtFaceValue(outcome, reporter)
        return

    # if this contract is for an market that triggerd a fork, migrate REP to outcome branch and then redeem it at face value
    self.market.finalize()
    if (isForkingMarket):
        self.privateRedeemTokensOnFork(outcome, reporter)
        return

    # for markets that resolve normally (non-fork) redeem correct outcome tokens proportionately to pot
    finalOutcome = self.market.getFinalOutcome()
    if (finalOutcome != outcome):
        ~invalid()
    self.privateRedeemTokensProportionately(outcome, reporter)

def extractBondHolderPayments():
    # TODO: assert market is finalized
    # TODO: send losing outcome REP to market until it has enough in coffers to cover bond rewards

####
#### Getters
####

def getWinningOutcome():
    return(self.winningOutcome)

def getWinningOutcomeCount():
    return(tokenSupply[self.winningOutcome])

def getLosingOutcomeCount():
    return(self.allOutcomeTokenSupply - self.getWinningOutcomeCount())

####
#### Asserts
####

def assertBranchMatchesMarketBranch():
    if (self.market.getBranch() != self.branchId):
        ~invalid()

def assertMarketIsNotDoneWithReporters():
    if (self.market.getAllReportersOutcome() != 0):
        ~invalid()

def assertReporterHasRegistrationToken(reporterAddress):
    reportingWindow = self.market.getReportingWindow()
    numberOfRegistrationTokens = REGISTRATION_TOKEN.balanceOf(self.branchId, reportingWindow, reporterAddress)
    if (numberOfRegistrationTokens < 1):
        ~invalid()
    return(1)

def assertReporterHasReported(outcome, reporter):
    if (not self.tokens[outcome][reporter]):
        ~invalid()

####
#### Private
####

def privateRedeemTokensProportionately(outcome, reporter):
    assertPrivateCall()
    # deduct tokens from reporter
    attotokens = self.tokens[outcome][reporter]
    startingTokenSupply = self.tokenSupply[outcome]
    startingAllOutcomesTokenSupply = self.allOutcomesTokenSupply
    self.tokens[outcome][reporter] = 0
    self.tokenSupply[outcome] = safeSub(startingTokenSupply, attotokens)
    self.allOutcomesTokenSupply = safeSub(startingAllOutcomesTokenSupply, attotokens)
    # give REP proportionate to rep_held_by_contract * tokens_being_destroyed / winning_outcome_token_supply
    reputationToDistribute = REPUTATION_TOKEN.balanceOf(self.branchId, self)
    reporterShare = attotokens
    totalShares = startingAllOutcomesTokenSupply
    reporterShareOfRep = reputationToDistribute * myShare / totalShares
    REPUTATION_TOKEN.transfer(reporter, reporterShareOfRep)

def privateRedeemTokensAtFaceValue(outcome, reporter):
    assertPrivateCall()
    # deduct tokens from reporter
    attotokens = self.tokens[outcome][reporter]
    startingTokenSupply = self.tokenSupply[outcome]
    startingAllOutcomesTokenSupply = self.allOutcomesTokenSupply
    self.tokens[outcome][reporter] = 0
    self.tokenSupply[outcome] = safeSub(startingTokenSupply, attotokens)
    self.allOutcomesTokenSupply = safeSub(startingAllOutcomesTokenSupply, attotokens)
    # send REP at 1:1 ratio to reporter
    REPUTATION_TOKEN.transfer(self.branchId, reporter, attotokens)

def privateRedeemTokensOnFork(outcome, reporter):
    assertPrivateCall()
    preForkBranchId = # TODO: get pre-fork branchId
    forkedOutcomeBranchId = BRANCHES_ACTIONS.computeBranchId(preForkBranchId, self.market.getMarketId(), outcome)
    attotokens = tokens[outcome][reporter]
    tokens[outcome][reporter] = 0
    REPUTATION_TOKEN.migrate(preForkBranchId, forkedOutcomeBranchId, attotokens)
    REPUTATION_TOKEN.transfer(forkedOutcomeBranchId, reporter, attotokens)

def privateCreateAndAssignTokens(outcome, reporter, attotokens):
    assertPrivateCall()
    startingAttotoken = self.tokens[outcome][reporter]
    startingTokenSupply = self.tokenSupply[outcome]
    startingAllOutcomesTokenSupply = self.allOutcomesTokenSupply
    self.tokens[outcome][reporter] = safeAdd(startingAttotoken, attotokens)
    self.tokenSupply[outcome] = safeAdd(startingTokenSupply, attotokens)
    self.allOutcomesTokenSupply = safeAdd(startingAllOutcomesTokenSupply, attotokens)

def privateAdjustWinningOutcome(outcome):
    assertPrivateCall()
    outcomeVolume = self.tokenSupply[outcome]
    currentWinningOutcome = self.winningOutcome
    currentWinningOutcomeVolume = self.tokenSupply[currentWinningOutcome]
    if (outcomeVolume > currentWinningOutcomeVolume):
        self.winningOutcome = outcome
