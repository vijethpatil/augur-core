# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern repContract: [allowance:[address,address]:uint256, approve:[address,uint256]:uint256, balanceOf:[address]:uint256, decimals:[]:uint256, getRidOfDustForLaunch:[]:int256, getSeeded:[]:uint256, name:[]:uint256, setSaleDistribution:[address[],uint256[]]:uint256, symbol:[]:uint256, totalSupply:[]:uint256, transfer:[address,uint256]:uint256, transferFrom:[address,address,uint256]:uint256]
extern reputationTokenErc20Wrapper: [allowance:[address,address]:int256, approve:[address,uint256]:int256, balanceOf:[address]:int256, initialize:[int256]:int256, totalSupply:[]:int256, transfer:[address,uint256]:int256, transferFrom:[address,address,uint256]:int256]
extern controller: [lookup:[int256]:int256, assertIsWhitelisted:[int256]:int256]
extern branches: [getForkingEvent:[int256]:int256, setForkingEvent:[int256,int256]:int256]

inset('../macros/safeMath.sem')
inset('../macros/refund.sem')

data controller
# tokens[branch][token_holder_address] returns attorep
data tokens[][2**160]
# spenders[branch][token_holder_address][spender_address] returns attorep
data spenders[][2**160][2**160]
# tokenSupply[branch] returns attorep
data tokenSupply[]
# erc20Tokens[branch] returns token contract address
data erc20Tokens[]
data name
data symbol
data decimals

event Transfer(branch:uint256:indexed, from:address:indexed, to:address:indexed, attorep:uint256)
event Approval(branch:uint256:indexed, owner:address:indexed, spender:address:indexed, attorep:uint256)

# TODO: change this to match the address of the REP contract on the target network
LEGACY_REP_CONTRACT = 0x0

def init():
    self.controller = 0x0
    self.name = "Reputation"
    self.symbol = "REP"
    self.decimals = 18
    # CONSIDER: should we copy over contents of 0x0000000000000000000000000000000000000000 from LEGACYREPCONTRACT? if so what do we do with them?

def any():
    refund()

# TODO Fix this wrapper thing doesn't work
def getErc20Token(branch):
    if (self.erc20Tokens[branch] == 0):
        contractAddress = create('reputationTokenErc20Wrapper.se')
        contractAddress.initialize(branch)
        self.erc20Tokens[branch] = contractAddress
    return(self.erc20Tokens[branch])

def migrate(sourceBranch, destinationBranch, attorepToMigrate):
    # validate that the source branch is actually forked/forking
    parentForkingEvent = self.controller.lookup('branches').getForkingEvent(sourceBranch)
    if (parentForkingEvent == 0):
        ~invalid()
    # validate that destinationBranch is a child of sourceBranch
    sourceBranchHashHighBits = sha3(sourceBranch) & 0xffffffffffffffff000000000000000000000000000000000000000000000000
    destinationBranchParentHashHighBits = destinationBranch & 0xffffffffffffffff000000000000000000000000000000000000000000000000
    if (sourceBranchHashHighBits != destinationBranchParentHashHighBits):
        ~invalid()
    # do the transfer
    startingTokensOnParent = self.tokens[sourceBranch][msg.sender]
    startingTokensOnChild = self.tokens[destinationBranch][msg.sender]
    startingSupplyOnParent = self.tokenSupply[sourceBranch]
    startingSupplyOnChild = self.tokenSupply[destinationBranch]
    self.tokens[sourceBranch][msg.sender] = safeSub(startingTokensOnParent, attorepToMigrate)
    self.tokens[destinationBranch][msg.sender] = safeAdd(startingTokensOnChild, attorepToMigrate)
    self.tokenSupply[sourceBranch] = safeSub(startingSupplyOnParent, attorepToMigrate)
    self.tokenSupply[destinationBranch] = safeAdd(startingSupplyOnChild, attorepToMigrate)
    return(1)

def migrateFromLegacyRepContract(branch):
    legacyBalance = LEGACY_REP_CONTRACT.balanceOf(msg.sender)
    startingBalance = self.tokens[branch][msg.sender]
    startingSupply = self.tokenSupply[branch]
    LEGACY_REP_CONTRACT.transferFrom(msg.sender, 0x0000000000000000000000000000000000000000, legacyBalance)
    self.tokens[branch][msg.sender] = safeAdd(startingBalance, legacyBalance)
    self.tokenSupply[branch] = safeAdd(startingSupply, legacyBalance)
    return(1)

####
#### ERC20-like implementation
####

def totalSupply(branch):
    return(self.tokenSupply[branch]: uint256)

def balanceOf(branch, address):
    return(self.tokens[branch][address]: uint256)

def transfer(branch, destinationAddress, attorep):
    return(self.privateTransfer(branch, msg.sender, destinationAddress, attorep))

def transferFrom(branch, sourceAddress, destinationAddress, attorep):
    startingLimit = self.spenders[branch][sourceAddress][msg.sender]
    self.spenders[branch][sourceAddress][msg.sender] = safeSub(startingLimit, attorep)
    return(self.privateTransfer(branch, sourceAddress, destinationAddress, attorep))

def approve(branch, spenderAddress, attorep):
    self.spenders[branch][msg.sender][spenderAddress] = attorep
    log(type = Approval, branch, msg.sender, spenderAddress, attorep)
    return(1)

def allowance(branch, ownerAddress, spenderAddress):
    return(self.spenders[branch][ownerAddress][spenderAddress]: uint256)

####
#### Private
####

macro privateOnly():
    if (msg.sender != self):
        ~invalid()

def privateTransfer(branch, sourceAddress, destinationAddress, attorep):
    privateOnly()
    startingSourceAttoRep = self.tokens[branch][sourceAddress]
    startingDestinationAttoRep = self.tokens[branch][destinationAddress]
    self.tokens[branch][sourceAddress] = safeSub(startingSourceAttoRep, attorep)
    self.tokens[branch][destinationAddress] = safeAdd(startingDestinationAttoRep, attorep)
    log(type = Transfer, branch, sourceAddress, destinationAddress, attorep)
    return(1)