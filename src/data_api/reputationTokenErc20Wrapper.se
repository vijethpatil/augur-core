# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern reputationToken: [allowance:[int256,int256,int256]:uint256, approve:[int256,int256,int256]:int256, balanceOf:[int256,int256]:uint256, getErc20Token:[int256]:int256, migrate:[int256,int256,int256]:int256, migrateFromLegacyRepContract:[int256]:int256, privateTransfer:[int256,int256,int256,int256]:int256, totalSupply:[int256]:uint256, transfer:[int256,int256,int256]:int256, transferFrom:[int256,int256,int256,int256]:int256]

inset('../macros/refund.sem')

data branch
data name
data symbol
data decimals
data branch
data backingContract

event Transfer(from:address:indexed, to:address:indexed, attorep:uint256)
event Approval(owner:address:indexed, spender:address:indexed, attorep:uint256)

def init():
    self.name = "Reputation"
    self.symbol = "REP"
    self.decimals = 18
    self.branch = 0
    self.backingContract = msg.sender

def any():
    refund()

def initialize(branch):
    if (self.branch != 0):
        ~invalid()
    self.branch = branch
    return(1)

# FIXME: I totally misunderstood how delegate calls worked when I wrote this, this won't work at all sadly.  :/
def totalSupply():
	return(self.backingContract.totalSupply(self.branch, call=delegate))

def balanceOf(address: address):
	return(self.backingContract.balanceOf(self.branch, address, call=delegate))

def transfer(destinationAddress: address, attorep: uint256):
    log(type=Transfer, msg.sender, destinationAddress, attorep)
    return(self.backingContract.transfer(self.branch, address, call=delegate))

def transferFrom(sourceAddress: address, destinationAddress: address, attorep: uint256):
    log(type=Transfer, sourceAddress, destinationAddress, attorep)
    return(self.backingContract.transferFrom(self.branch, sourceAddress, destinationAddress, attorep, call=delegate))

def approve(spenderAddress: address, attorep: uint256):
    log(type=Approval, msg.sender, spenderAddress, attorep)
    return(self.backingContract.approve(self.branch, spenderAddress, attorep, call=delegate))

def allowance(ownerAddress: address, spenderAddress: address):
    return(self.backingContract.allowance(self.branch, ownerAddress, spenderAddress, call=delegate))