# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controller: [lookup:[str]:address, assertIsWhitelisted:[address]:uint256, assertOnlySpecifiedCaller:[address, str]:_]

inset('../macros/refund.sem')

data controller

BRANCH_STORAGE = self.controller.lookup('branchStorage')
extern branchesData: [getForkingMarket:[uint256]:uint256, setForkingMarket:[uint256,uint256]:_]

inset('../macros/refund.sem')

def init():
    self.controller = 0x0

def any():
    refund()

def setForkingMarket(branch, market):
    if(BRANCHES.getForkingMarket(branch) != 0):
        ~invalid()
    BRANCHES.setForkingMarket(branch, market)

def computeBranchId(branch, marketId, outcome):
    parentBranchBits = sha3(branch) & 0xffffffffffffffff000000000000000000000000000000000000000000000000
    marketBits = (sha3(marketId) << 128) & 0x0000000000000000ffffffffffffffff00000000000000000000000000000000
    # FIXME: this probably doesn't work with negative numbers
    outcomeBits = sha3(outcome) & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff
    outcomeBranchId = parentBranchBits | marketBits | outcomeBits
    return(outcomeBranchId)
