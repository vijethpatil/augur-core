# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controller: [lookup:[int256]:int256, assertIsWhitelisted:[int256]:int256]

BRANCHES = self.controller.lookup('branches')
extern branches: [getForkingEvent:[int256]:int256, setForkingEvent:[int256,int256]:int256]

EVENTS = self.controller.lookup('events')
extern events: [allowance:[int256,int256]:uint256, approve:[int256,int256]:int256, assertEventIsInAutomatedReportDisputePhase:[int256]:int256, assertEventIsInAutomatedReportPhase:[int256]:int256, assertEventIsInCurrentReportingWindow:[int256]:int256, assertEventIsInDisputePhase:[int256]:int256, assertEventIsInReportingPhase:[int256]:int256, assertEventIsNotDoneWithReporters:[int256]:int256, assertEventIsNotFinalized:[int256]:int256, assertReporterHasRegistrationToken:[int256]:int256, automatedReport:[int256,int256]:_, balanceOf:[int256,int256,int256,int256]:uint256, createEvent:[int256,int256,int256,int256]:int256, disputeAllReporters:[int256]:_, disputeAutomatedReport:[int256]:_, disputeLimitedReporters:[int256]:_, finalizeEvent:[int256]:_, getAutomatedReportDisputeDueTimestamp:[int256]:int256, getAutomatedReportDueTimestamp:[int256]:int256, getEventBranch:[int256]:int256, getNumberOfAllReporterEvents:[int256,int256]:int256, getNumberOfLimitedReporterEvents:[int256,int256]:int256, isEventFinalized:[int256]:int256, migrateEventThroughAllForks:[int256]:int256, migrateEventThroughOneFork:[int256]:int256, privateAdjustTentativeOutcome:[int256,int256]:_, privateBuyToken:[int256,int256,int256,int256]:_, privateRedeemCorrectOutcomeTokens:[int256,int256,int256,int256]:int256, privateTransfer:[int256,int256,int256,int256,int256,int256]:int256, privateTryRedeemTokensForNonForkingEventOnForkedBranch:[int256,int256,int256,int256]:int256, privateTryRedeemTokensOnForkingEvent:[int256,int256,int256,int256]:int256, redeemTokens:[int256,int256,int256]:int256, report:[int256,int256,int256]:int256, totalSupply:[int256,int256,int256]:uint256, transfer:[int256,int256,int256,int256,int256]:int256, transferFrom:[int256,int256,int256,int256,int256,int256]:int256, tryFinalizeEvent:[int256]:int256]

REPORTING = self.controller.lookup('reporting')
extern reporting: [assertCanReportOnEvent:[int256,int256]:int256, assertDoneReporting:[int256,int256,int256]:int256, clearUserReports:[int256,int256,int256]:int256, getCurrentReportingWindow:[]:int256, getCurrentReportingWindowEndTimestamp:[]:int256, getCurrentReportingWindowStartTimestamp:[]:int256, getReportingPeriodDurationInSeconds:[]:int256, getReportingWindowForTimestamp:[int256]:int256, getTargetReportsPerReporter:[int256,int256]:int256, getUserSeed:[int256,int256,int256]:int256, isInReportingDisputePhase:[]:int256, isInReportingPhase:[]:int256, noteUserReport:[int256,int256]:int256]

MARKETS = self.controller.lookup('markets')
extern markets: [addFees:[int256,int256]:int256, addToMarketsHash:[int256,int256]:int256, getBondsMan:[int256]:int256, getBranch:[int256]:int256, getCumulativeScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getGasSubsidy:[int256]:int256, getLastExpDate:[int256]:int256, getMarketEvent:[int256]:int256, getMarketNumOutcomes:[int256]:int256, getMarketResolved:[int256]:int256, getMarketShareContracts:[int256]:int256[], getMarketsHash:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getOutcomeShareContract:[int256,int256]:int256, getOutcomeShareWallet:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:uint256, getSharesValue:[int256]:int256, getTags:[int256]:int256[], getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, initializeMarket:[int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256,int256[],int256[]]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, setController:[address]:int256, setMarketResolved:[int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, suicideFunds:[address]:_]

MUTEX = self.controller.lookup('mutex')
extern mutex: [acquire:[]:int256, release:[]:int256, setController:[address]:int256, suicideFunds:[address]:_]

extern subcurrency: [allowance:[address,address]:uint256, approve:[address,uint256]:uint256, balanceOf:[address]:uint256, decimals:[]:uint256, name:[]:uint256, symbol:[]:uint256, totalSupply:[]:uint256, transfer:[address,uint256]:uint256, transferFrom:[address,address,uint256]:uint256]

extern forkResolveContract: [resolveFork:[int256]:int256]

extern wallet: [initialize:[int256]:int256, setController:[address]:int256, suicideFunds:[address]:_, transfer:[address,uint256]:int256]

inset('../macros/refund.sem')
inset('../macros/safeMath.sem')
inset('../macros/unitConversions.sem')

data controller

macro POINT_ZERO_THREE: 553402322211286528
macro COST_PER_REPORTER: 3500000
macro COST_FOR_EVENT_REPORT_CALCULATION: 500000
macro MAX_FEE: 10 ** 17
macro THREE_DAYS: 259200
macro FIRST_RESOLVE_BOND: 11 * WEI_TO_ETH
macro SECONDS_PER_YEAR: 31557600
macro 10_PERCENT_RATE: 100000000000000000
# may want to reconfirm this again
macro COST_FOR_MARKET_RESOLUTION: 1000000

macro checkForkResolveContractIsValid($contract):
    resolve = $contract.resolveFork(1)


### Allows creation of events and markets and manipulating them

# Create an event. Events are the basic units / questions that are reported on in Augur by reporters
# @param numOutcomes is number of outcomes for this event, e.g. quarter mile times from 10.0 to 11.0 would be 11 outcomes (if incremented by 0.1)
# @param fxpMinValue should be 10**18 for a binary event, fxpMaxValue should be 2**65 for a binary event
# @param fxpMinValue for a scalar from 0 to 100 should be 0 and max should be 100*10**18, for -100 to 200, it should be -100*10**18 and 200*10**18 respectively
# @param description is a description of the event / the question itself
# @param resolution is the string source/link to resolve the event
# @param branch is the branch the event is created in
# @param expDate is the epoch time in which the event expires
# @param resolutionAddress is the address that resolves an event in the beginning
# @param forkResolveAddress is the address for the contract for an event to use to resolve a fork, it's an optional parameter so may be 0 if the event chooses to use the default fork resolution, it should whitelist forking.se
# @return event if success
# range between min and max should be 1 [in fxp] or greater
# .025 eth to create
# TODO replace with outcome labels as separate int256[] param
# descriptionWithoutOutcomeLabels + "~|>" + outcome1label + "|"  + outcome2label + "|" + outcome3label is format for a description
# with a categorical user can set min and max to whatever, for reporting 1 is the min and max is the max then reports should be scaled between that range from 0-2, for payouts it's 1 to the winning outcome or equal for all outcomes if indeterminate, you cannot trade by paying more than 1 for a share as that makes no sense
# for binary it's 1 as min and 2 as max
def init():
    self.controller = 0x0

def publicCreateEvent(branch, description: str, expDate, fxpMinValue, fxpMaxValue, numOutcomes, resolution: str, resolutionAddress, currency, forkResolveAddress):
    refund()
    MUTEX.acquire()
    event = self.createEvent(msg.sender, branch, description, expDate, fxpMinValue, fxpMaxValue, numOutcomes, resolution, resolutionAddress, currency, forkResolveAddress)
    MUTEX.release()
    return(event)

def createEvent(sender: address, branch, description: str, expDate, fxpMinValue, fxpMaxValue, numOutcomes, resolution: str, resolutionAddress, currency, forkResolveAddress):
    refund()
    self.controller.assertIsWhitelisted(msg.sender)

    periodLength = BRANCHES.getPeriodLength(branch)
    if(numOutcomes > 2):
        fxpMinValue = WEI_TO_ETH
        fxpMaxValue = safeMul(numOutcomes, WEI_TO_ETH)
    self.checkEventCreationPreconditions(branch, periodLength, description, expDate, fxpMinValue, fxpMaxValue, numOutcomes, resolution, resolutionAddress, currency, forkResolveAddress)

    eventInfo = string(8 * 32 + len(description))
    eventInfo[0] = branch                                       # branch
    eventInfo[1] = expDate                                      # expiration date
    eventInfo[2] = sender                                       # creator address
    eventInfo[3] = periodLength
    eventInfo[4] = fxpMinValue                                  # minimum outcome value
    eventInfo[5] = fxpMaxValue                                  # maximum outcome value
    eventInfo[6] = numOutcomes                                  # number of outcomes
    eventInfo[7] = resolutionAddress
    mcopy(eventInfo + 8 * 32, description, len(description))
    event = ripemd160(eventInfo, chars = len(eventInfo))
    if(INFO.getCreator(event)):
        ~invalid()

    wallet = create('wallet.se')
    wallet.initialize(currency)

    REPORTING.addReporter(branch, event, 0, 0, 0)

    firstResolveBondPaid = 0
    firstResolveBondPoster = 0
    # sender / event creator paid
    # todo add if no resolution address just put in regular vote period as normal but charge extra
    if (REPORTING.getRepBalance(branch, sender) >= FIRST_RESOLVE_BOND):
        if(REPORTING.subtractRep(branch, REPORTING.repIDToIndex(branch, sender), FIRST_RESOLVE_BOND) and REPORTING.addRep(branch, REPORTING.repIDToIndex(branch, event), FIRST_RESOLVE_BOND)):
            firstResolveBondPaid = 1
            firstResolveBondPoster = sender
    if(INFO.setInfo(event, description, sender, 0, currency, wallet) and EVENTS.initializeEvent(event, branch, expDate, fxpMinValue, fxpMaxValue, numOutcomes, resolution, resolutionAddress, firstResolveBondPoster, forkResolveAddress) and firstResolveBondPaid):
        if(!EVENTS.getBond(event)):
            # pay validity / indeterminate protection bond
            period = block.timestamp / TWENTY_FOUR_HR
            baseReporters = BRANCHES.getBaseReporters(branch)
            minFee = safeFxpMul(safeMul(safeMul(COST_PER_REPORTER, baseReporters), tx.gasprice), BRANCHES.getCurrencyRate(branch, currency))
            if(!minFee):
                ~invalid()
            validityBond = (minFee * (1 + EVENTS.getPast24(period)) / (1 + EXPEVENTS.getNumberEvents(branch, BRANCHES.getVotePeriod(branch)))) / 2
            if(!currency.transferFrom(sender, wallet, validityBond)):
                ~invalid()
            EVENTS.setExpiration(event, expDate)
            EVENTS.setBond(event, validityBond)
            EVENTS.addPast24(period)
        return(event)
    else:
        ~invalid()

def checkEventCreationPreconditions(branch, periodLength, description: str, expDate, fxpMinValue, fxpMaxValue, numOutcomes, resolution: str, resolutionAddress, currency, forkResolveAddress):
    if(msg.sender != self):
        ~invalid()
    if(!periodLength):
        ~invalid()
    if(!len(description)):
        ~invalid()
    if(!len(resolution)):
        ~invalid()
    if(expDate < block.timestamp):
        ~invalid()
    if (!resolutionAddress):
        ~invalid()
    if(fxpMaxValue < fxpMinValue):
        ~invalid()
    if((fxpMaxValue - fxpMinValue) < WEI_TO_ETH):
        ~invalid()
    if((fxpMaxValue + fxpMinValue) < fxpMaxValue):
        ~invalid()
    if(numOutcomes < 2 or numOutcomes > 8):
        ~invalid()
    parent = BRANCHES.getParent(branch)
    parentLastForked = BRANCHES.getForkPeriod(parent)
    fortyEightHourPeriodWhereNoEventsCanExpireOnNewFork = parentLastForked + 1
    whenEventExpires = expDate / periodLength
    if(whenEventExpires == fortyEightHourPeriodWhereNoEventsCanExpireOnNewFork):
        ~invalid()
    if(!BRANCHES.getCurrencyActive(branch, currency)):
        ~invalid()
    checkForkResolveContractIsValid(forkResolveAddress)

def setController(newController: address):
    if(msg.sender != self.controller):
        ~invalid()
    self.controller = newController
    return(1)

def suicideFunds(to: address):
    if(msg.sender != self.controller):
        ~invalid()
    suicide(to)