# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controller: [lookup:[int256]:int256, assertIsWhitelisted:[int256]:int256]

BRANCHES = self.controller.lookup('branches')
extern branches: [getForkingEvent:[int256]:int256, setForkingEvent:[int256,int256]:int256]

EVENTS = self.controller.lookup('events')
extern events: [allowance:[int256,int256]:uint256, approve:[int256,int256]:int256, assertEventIsInAutomatedReportDisputePhase:[int256]:int256, assertEventIsInAutomatedReportPhase:[int256]:int256, assertEventIsInCurrentReportingWindow:[int256]:int256, assertEventIsInDisputePhase:[int256]:int256, assertEventIsInReportingPhase:[int256]:int256, assertEventIsNotDoneWithReporters:[int256]:int256, assertEventIsNotFinalized:[int256]:int256, assertReporterHasRegistrationToken:[int256]:int256, automatedReport:[int256,int256]:_, balanceOf:[int256,int256,int256,int256]:uint256, createEvent:[int256,int256,int256,int256]:int256, disputeAllReporters:[int256]:_, disputeAutomatedReport:[int256]:_, disputeLimitedReporters:[int256]:_, finalizeEvent:[int256]:_, getAutomatedReportDisputeDueTimestamp:[int256]:int256, getAutomatedReportDueTimestamp:[int256]:int256, getEventBranch:[int256]:int256, getNumberOfAllReporterEvents:[int256,int256]:int256, getNumberOfLimitedReporterEvents:[int256,int256]:int256, isEventFinalized:[int256]:int256, migrateEventThroughAllForks:[int256]:int256, migrateEventThroughOneFork:[int256]:int256, privateAdjustTentativeOutcome:[int256,int256]:_, privateBuyToken:[int256,int256,int256,int256]:_, privateRedeemCorrectOutcomeTokens:[int256,int256,int256,int256]:int256, privateTransfer:[int256,int256,int256,int256,int256,int256]:int256, privateTryRedeemTokensForNonForkingEventOnForkedBranch:[int256,int256,int256,int256]:int256, privateTryRedeemTokensOnForkingEvent:[int256,int256,int256,int256]:int256, redeemTokens:[int256,int256,int256]:int256, report:[int256,int256,int256]:int256, totalSupply:[int256,int256,int256]:uint256, transfer:[int256,int256,int256,int256,int256]:int256, transferFrom:[int256,int256,int256,int256,int256,int256]:int256, tryFinalizeEvent:[int256]:int256]

REPORTING = self.controller.lookup('reporting')
extern reporting: [assertCanReportOnEvent:[int256,int256]:int256, assertDoneReporting:[int256,int256,int256]:int256, clearUserReports:[int256,int256,int256]:int256, getCurrentReportingWindow:[]:int256, getCurrentReportingWindowEndTimestamp:[]:int256, getCurrentReportingWindowStartTimestamp:[]:int256, getReportingPeriodDurationInSeconds:[]:int256, getReportingWindowForTimestamp:[int256]:int256, getTargetReportsPerReporter:[int256,int256]:int256, getUserSeed:[int256,int256,int256]:int256, isInReportingDisputePhase:[]:int256, isInReportingPhase:[]:int256, noteUserReport:[int256,int256]:int256]

MARKETS = self.controller.lookup('markets')
extern markets: [addFees:[int256,int256]:int256, addToMarketsHash:[int256,int256]:int256, getBondsMan:[int256]:int256, getBranch:[int256]:int256, getCumulativeScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getGasSubsidy:[int256]:int256, getLastExpDate:[int256]:int256, getMarketEvent:[int256]:int256, getMarketNumOutcomes:[int256]:int256, getMarketResolved:[int256]:int256, getMarketShareContracts:[int256]:int256[], getMarketsHash:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getOutcomeShareContract:[int256,int256]:int256, getOutcomeShareWallet:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:uint256, getSharesValue:[int256]:int256, getTags:[int256]:int256[], getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, initializeMarket:[int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256,int256[],int256[]]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, setController:[address]:int256, setMarketResolved:[int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, suicideFunds:[address]:_]

ORDERS = self.controller.lookup('orders')
extern orders: [addOrder:[int256,int256]:int256, cancelOrderLog:[int256,int256,int256,int256,int256,int256,int256,int256,int256]:int256, checkHash:[int256,int256]:int256, commitOrder:[int256]:int256, completeSetsLog:[int256,int256,int256,int256,int256,int256]:int256, fillOrder:[int256,int256,int256,int256]:int256, getAmount:[int256]:int256, getID:[int256]:int256, getLastOrder:[int256]:int256, getLastOutcomePrice:[int256,int256]:int256, getOrder:[int256]:int256[], getOrderIDs:[int256]:int256[], getOrderOwner:[int256]:int256, getPrevID:[int256,int256]:int256, getPrice:[int256]:int256, getTotalOrders:[int256]:int256, getType:[int256]:int256, getVolume:[int256]:int256, makeOrderHash:[int256,int256,int256]:int256, modifyMarketVolume:[int256,int256]:int256, removeOrder:[int256]:int256, removeOrderFromMarket:[int256,int256]:int256, saveOrder:[int256,int256,int256,int256,int256,int256,int256,int256,int256,int256]:int256, setController:[address]:int256, setPrice:[int256,int256,int256]:int256, suicideFunds:[address]:_, takeAskOrderLog:[address,address,address,int256,uint256,address,uint256,uint256,uint256,uint256,uint256]:int256, takeBidOrderLog:[address,address,address,int256,uint256,address,uint256,uint256,uint256,uint256,uint256,uint256]:int256]

COMPLETESETS = self.controller.lookup('completeSets')
extern completeSets: [buyCompleteSets:[address,address,uint256]:int256, publicBuyCompleteSets:[address,uint256]:int256, publicSellCompleteSets:[address,uint256]:int256, sellCompleteSets:[address,address,uint256]:int256, setController:[address]:int256, suicideFunds:[address]:_]

extern shareTokens: [allowance:[address,address]:int256, approve:[address,uint256]:int256, balanceOf:[address]:int256, createShares:[address,uint256]:int256, destroyShares:[address,uint256]:int256, getDecimals:[]:int256, getName:[]:int256, getSymbol:[]:int256, setController:[address]:int256, suicideFunds:[address]:_, totalSupply:[]:int256, transfer:[address,uint256]:int256, transferFrom:[address,address,uint256]:int256]

extern subcurrency: [allowance:[address,address]:uint256, approve:[address,uint256]:uint256, balanceOf:[address]:uint256, decimals:[]:uint256, name:[]:uint256, symbol:[]:uint256, totalSupply:[]:uint256, transfer:[address,uint256]:uint256, transferFrom:[address,address,uint256]:uint256]

extern wallet: [initialize:[int256]:int256, setController:[address]:int256, suicideFunds:[address]:_, transfer:[address,uint256]:int256]

inset('../macros/refund.sem')
inset('../macros/safeMath.sem')
inset('../macros/unitConversions.sem')

data controller

macro MIN_TRADE_VALUE: 10000000000000000
macro MAX_INT256_VALUE: 2**255 - 1

# Trade types
macro BID: 1
macro ASK: 2

# Field counts
macro ORDER_FIELDS: 10

def init():
    self.controller = 0x0

# Filling an ask [aka buying shares]
# Scenarios:
#  - Asker (maker) escrowed maxValue - price and expects complete set minus the one they're selling
#  - Asker (maker) had shares and escrowed them and expects to be paid price - minValue for them
#  - Bidder (taker/sender) pays price - minValue for their shares
def takeAskOrder(sender: address, orderID: address, fxpAmountTakerWants: uint256):
    refund()
    self.controller.assertIsWhitelisted(msg.sender)

    # Get order
    order = array(ORDER_FIELDS)
    order = ORDERS.getOrder(orderID, outitems=ORDER_FIELDS)
    type = order[1]
    market = order[2]
    fxpAmount = order[3]
    fxpPrice = order[4]
    maker = order[5]
    outcome = order[7]
    fxpMoneyEscrowed = order[8]
    fxpSharesEscrowed = order[9]

    # Check trade preconditions
    if(!order[0]):
        ~invalid()
    if(maker == sender):
        ~invalid()
    # Make sure the order has been mined, obvious HFT prevention
    if(block.number <= order[6]):
        ~invalid()

    orderInfo = array(4)
    orderInfo[0] = market
    orderInfo[1] = outcome
    orderInfo[2] = type
    orderInfo[3] = sender
    orderHash = ripemd160(orderInfo, items=4)
    ORDERS.checkHash(orderHash, sender)

    branch = EVENTS.getExpiration(MARKETS.getMarketEvent(market))
    event = MARKETS.getMarketEvent(market)
    if(EVENTS.getEventType(event) == "scalar"):
        fxpMaxValue = EVENTS.getMaxValue(event)
    else:
        fxpMaxValue = TWO
    fxpMinValue = EVENTS.getMinValue(event)
    fxpCumulativeScale = MARKETS.getCumulativeScale(market)

    fxpSumOfFills = 0

    # All in shares including the money here
    fxpAskerSharesFilled = 0
    fxpAskerMoneyFilled = 0
    fxpBidderMoneyFilled = 0

    # Account for ask-with-shares
    #  - Asker had shares and escrowed them and expects to be paid price - minValue for them
    if(fxpSharesEscrowed > 0):
        fxpFill = min(fxpSharesEscrowed, fxpAmountTakerWants)
        fxpAmountTakerWants = safeSub(fxpAmountTakerWants, fxpFill)
        fxpSumOfFills = safeAdd(fxpSumOfFills, fxpFill)
        # Transfer fxpFill shares from market's escrow (shares) wallet to taker
        MARKETS.getOutcomeShareWallet(market, outcome).transfer(sender, fxpFill)
        fxpAskerSharesFilled = fxpFill

    # Account for short-ask
    #  - Asker escrowed maxValue - price and expects complete set minus the one they're selling
    if(fxpAmountTakerWants > 0 and fxpMoneyEscrowed > 0):
        fxpFill = min(safeFxpDiv(fxpMoneyEscrowed, safeSub(fxpMaxValue, fxpPrice)), fxpAmountTakerWants)
        fxpAmountTakerWants = safeSub(fxpAmountTakerWants, fxpFill)
        fxpSumOfFills = safeAdd(fxpSumOfFills, fxpFill)
        fxpAskerMoneyFilled = fxpFill
        # Issue asker complete sets (minus outcome) for fill amount; don't charge because the asker has already paid
        i = 1
        while i < MARKETS.getMarketNumOutcomes(market):
            if(i != outcome):
                MARKETS.getOutcomeShareContract(market, i).createShares(maker, fxpFill)
            i += 1
        # Issue taker the fill amount for the remaining outcome
        MARKETS.getOutcomeShareContract(market, outcome).createShares(sender, fxpFill)

    # Update ask order with fill info
    fxpRemainderToFill = fxpSumOfFills

    # Calculate value: must fill at least 0.00000001 in value
    if(safeFxpMul(fxpSumOfFills, fxpPrice) < MIN_TRADE_VALUE):
        ~invalid()

    # Update order amount or remove
    if(fxpSumOfFills < fxpAmount):
        ORDERS.fillOrder(orderID, fxpSumOfFills, safeFxpMul(fxpAskerMoneyFilled, safeSub(fxpMaxValue, fxpPrice)), fxpAskerSharesFilled)
    else:
        ORDERS.removeOrder(orderID)
        ORDERS.removeOrderFromMarket(market, orderID)

    # Account for buyer (bidding with cash)
    #  - Bidder will pay price - minValue for their shares
    if(fxpRemainderToFill > 0):
        fxpBidderMoneyFilled = fxpRemainderToFill

    # Add fxpSumOfFills to the market's volume
    ORDERS.modifyMarketVolume(market, fxpSumOfFills)

    # Sell taker complete sets
    fxpSharesHeld = MAX_INT256_VALUE
    i = 1
    while(i <= MARKETS.getMarketNumOutcomes(market)):
        fxpSharesHeld = min(MARKETS.getParticipantSharesPurchased(market, sender, i), fxpSharesHeld)
        i += 1
    if(fxpSharesHeld > 0):
        COMPLETESETS.sellCompleteSets(sender, market, fxpSharesHeld, call=delegate)

    # Transfer (price - minValue) * fxpBidderMoneyFilled to market from bidder since market hasn't been paid yet
    if(fxpBidderMoneyFilled > 0):
        if(!INFO.getCurrency(market).transferFrom(sender, INFO.getWallet(market), safeFxpMul(safeSub(fxpPrice, fxpMinValue), fxpBidderMoneyFilled))):
            ~invalid()

    # Transfer (price - minValue) * fxpAskerSharesFilled from the market to the asker, don't
    # need to send for fxpAskerMoneyFilled because asker only escrowed maxValue - price and thus
    # has "already been paid" for those shares.
    # Note: bidder has already sent their money to the market, so this money comes from the market.
    if(fxpAskerSharesFilled > 0):
        if(!INFO.getWallet(market).transfer(maker, safeFxpMul(safeSub(fxpPrice, fxpMinValue), fxpAskerSharesFilled))):
            ~invalid()

    # Sell maker's complete sets
    fxpSharesHeld = MAX_INT256_VALUE
    i = 1
    while(i <= MARKETS.getMarketNumOutcomes(market)):
        fxpSharesHeld = min(MARKETS.getParticipantSharesPurchased(market, maker, i), fxpSharesHeld)
        i += 1
    if(fxpSharesHeld > 0):
        COMPLETESETS.sellCompleteSets(maker, market, fxpSharesHeld, call=delegate)

    ORDERS.takeAskOrderLog(market, sender, maker, fxpPrice, fxpSumOfFills, orderID, outcome, fxpAskerSharesFilled, fxpAskerMoneyFilled, fxpBidderMoneyFilled)
    ORDERS.setPrice(market, outcome, fxpPrice)
    # balance of market should be equal to completeSets*range
    if((INFO.getCurrency(market).balanceOf(INFO.getWallet(market))) < safeFxpMul(MARKETS.getSharesPurchased(market, outcome), MARKETS.getCumulativeScale(market))):
        ~invalid()
    return(fxpAmountTakerWants: uint256)

def setController(newController: address):
    if(msg.sender != self.controller):
        ~invalid()
    self.controller = newController
    return(1)

def suicideFunds(to: address):
    if(msg.sender != self.controller):
        ~invalid()
    suicide(to)