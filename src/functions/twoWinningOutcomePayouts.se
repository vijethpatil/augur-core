# Copyright (C) 2015 Forecast Foundation OU, full GPL notice in LICENSE

extern controller: [lookup:[int256]:int256, assertIsWhitelisted:[int256]:int256]

MARKETS = self.controller.lookup('markets')
extern markets: [addFees:[int256,int256]:int256, addToMarketsHash:[int256,int256]:int256, getBondsMan:[int256]:int256, getBranch:[int256]:int256, getCumulativeScale:[int256]:int256, getExtraInfo:[int256]:bytes, getExtraInfoLength:[int256]:int256, getFees:[int256]:int256, getGasSubsidy:[int256]:int256, getLastExpDate:[int256]:int256, getMarketEvent:[int256]:int256, getMarketNumOutcomes:[int256]:int256, getMarketResolved:[int256]:int256, getMarketShareContracts:[int256]:int256[], getMarketsHash:[int256]:int256, getOriginalTradingPeriod:[int256]:int256, getOutcomeShareContract:[int256,int256]:int256, getOutcomeShareWallet:[int256,int256]:int256, getParticipantSharesPurchased:[int256,int256,int256]:int256, getPushedForward:[int256]:int256, getSharesPurchased:[int256,int256]:uint256, getSharesValue:[int256]:int256, getTags:[int256]:int256[], getTopic:[int256]:int256, getTotalSharesPurchased:[int256]:int256, getTradingFee:[int256]:int256, getTradingPeriod:[int256]:int256, initializeMarket:[int256,int256,int256,int256,int256,int256,int256,int256,int256,int256,bytes,int256,int256,int256,int256[],int256[]]:int256, modifySharesValue:[int256,int256]:int256, refundClosing:[int256,int256]:int256, setController:[address]:int256, setMarketResolved:[int256]:int256, setPushedForward:[int256,int256,int256]:int256, setTradingFee:[int256,int256]:int256, setTradingPeriod:[int256,int256]:int256, suicideFunds:[address]:_]

EVENTS = self.controller.lookup('events')
extern events: [allowance:[int256,int256]:uint256, approve:[int256,int256]:int256, assertEventIsInAutomatedReportDisputePhase:[int256]:int256, assertEventIsInAutomatedReportPhase:[int256]:int256, assertEventIsInCurrentReportingWindow:[int256]:int256, assertEventIsInDisputePhase:[int256]:int256, assertEventIsInReportingPhase:[int256]:int256, assertEventIsNotDoneWithReporters:[int256]:int256, assertEventIsNotFinalized:[int256]:int256, assertReporterHasRegistrationToken:[int256]:int256, automatedReport:[int256,int256]:_, balanceOf:[int256,int256,int256,int256]:uint256, createEvent:[int256,int256,int256,int256]:int256, disputeAllReporters:[int256]:_, disputeAutomatedReport:[int256]:_, disputeLimitedReporters:[int256]:_, finalizeEvent:[int256]:_, getAutomatedReportDisputeDueTimestamp:[int256]:int256, getAutomatedReportDueTimestamp:[int256]:int256, getEventBranch:[int256]:int256, getNumberOfAllReporterEvents:[int256,int256]:int256, getNumberOfLimitedReporterEvents:[int256,int256]:int256, isEventFinalized:[int256]:int256, migrateEventThroughAllForks:[int256]:int256, migrateEventThroughOneFork:[int256]:int256, privateAdjustTentativeOutcome:[int256,int256]:_, privateBuyToken:[int256,int256,int256,int256]:_, privateRedeemCorrectOutcomeTokens:[int256,int256,int256,int256]:int256, privateTransfer:[int256,int256,int256,int256,int256,int256]:int256, privateTryRedeemTokensForNonForkingEventOnForkedBranch:[int256,int256,int256,int256]:int256, privateTryRedeemTokensOnForkingEvent:[int256,int256,int256,int256]:int256, redeemTokens:[int256,int256,int256]:int256, report:[int256,int256,int256]:int256, totalSupply:[int256,int256,int256]:uint256, transfer:[int256,int256,int256,int256,int256]:int256, transferFrom:[int256,int256,int256,int256,int256,int256]:int256, tryFinalizeEvent:[int256]:int256]

BRANCHES = self.controller.lookup('branches')
extern branches: [getForkingEvent:[int256]:int256, setForkingEvent:[int256,int256]:int256]

extern shareTokens: [allowance:[address,address]:int256, approve:[address,uint256]:int256, balanceOf:[address]:int256, createShares:[address,uint256]:int256, destroyShares:[address,uint256]:int256, getDecimals:[]:int256, getName:[]:int256, getSymbol:[]:int256, setController:[address]:int256, suicideFunds:[address]:_, totalSupply:[]:int256, transfer:[address,uint256]:int256, transferFrom:[address,address,uint256]:int256]

extern subcurrency: [allowance:[address,address]:uint256, approve:[address,uint256]:uint256, balanceOf:[address]:uint256, decimals:[]:uint256, name:[]:uint256, symbol:[]:uint256, totalSupply:[]:uint256, transfer:[address,uint256]:uint256, transferFrom:[address,address,uint256]:uint256]

inset('../macros/refund.sem')
inset('../macros/safeMath.sem')
inset('../macros/unitConversions.sem')

data controller

# Payout traders in markets
def init():
    self.controller = 0x0

def twoOutcomes(market, event, sender):
    self.controller.assertIsWhitelisted(msg.sender)
    # fetch outcome and min/max values for the scalar
    outcome = EVENTS.getOutcome(event)
    minValue = EVENTS.getMinValue(event)
    maxValue = EVENTS.getMaxValue(event)
    currency = INFO.getCurrency(market)
    branch = EVENTS.getExpiration(MARKETS.getMarketEvent(market))
    # price is in fixed point
    # share two goes with the high/long side
    pricePerShare2 = safeFxpDiv(outcome - minValue, maxValue - minValue)
    # share one goes with the low/short side of the calc
    pricePerShare1 = safeSub(WEI_TO_ETH, pricePerShare2)
    # normalize if not exactly 100%
    if(safeAdd(pricePerShare1, pricePerShare2) != WEI_TO_ETH):
        denominator = safeAdd(pricePerShare1, pricePerShare1)
        pricePerShare1 = safeFxpDiv(pricePerShare1, denominator)
        pricePerShare2 = safeFxpDiv(pricePerShare2, denominator)

    # for each winning outcome get rid of shares and send money to the trader
    cumulativeScale = MARKETS.getCumulativeScale(market)

    # low side
    sharesOwned = MARKETS.getParticipantSharesPurchased(market, sender, 1)
    MARKETS.getOutcomeShareContract(market, 1).destroyShares(sender, sharesOwned)
    shareValue = safeFxpMul(safeFxpMul(sharesOwned, cumulativeScale), pricePerShare1)
    fee = safeFxpMul(MARKETS.getTradingFee(market), shareValue)
    if(shareValue != 0 and fee != 0):
        if(!INFO.getWallet(market).transfer(BRANCHES.getBranchWallet(branch, currency), safeDiv(fee, 2)) or !INFO.getWallet(market).transfer(INFO.getCreator(market), safeDiv(fee, 2))):
            ~invalid()
        if(!INFO.getWallet(market).transfer(sender, safeSub(shareValue, fee))):
            ~invalid()

    # high side (of the scalar part)
    sharesOwned = MARKETS.getParticipantSharesPurchased(market, sender, 2)
    MARKETS.getOutcomeShareContract(market, 2).destroyShares(sender, sharesOwned)
    shareValue = safeFxpMul(safeFxpMul(sharesOwned, cumulativeScale), pricePerShare2)
    fee = safeFxpMul(MARKETS.getTradingFee(market), shareValue)
    if(shareValue != 0 and fee != 0):
        if(!INFO.getWallet(market).transfer(BRANCHES.getBranchWallet(branch, currency), safeDiv(fee, 2)) or !INFO.getWallet(market).transfer(INFO.getCreator(market), safeDiv(fee, 2))):
            ~invalid()
        if(!INFO.getWallet(market).transfer(sender, safeSub(shareValue, fee))):
            ~invalid()
    return(1)

def setController(newController: address):
    if(msg.sender != self.controller):
        ~invalid()
    self.controller = newController
    return(1)

def suicideFunds(to: address):
    if(msg.sender != self.controller):
        ~invalid()
    suicide(to)